#!/usr/bin/env ruby -w

require 'optparse'  # Use OptionParser to parse command line args
require 'net/http'  # Use Net::HTTP to fetch ticker info from Google and Yahoo
require 'uri'       # Parse URIs

module RTicker

  # Default ticker entry file $HOME/.rticker
  DEFAULT_ENTRY_FILE = "#{ENV['HOME']}/.rticker"

  ##############################
  # Parent class to represent all types of ticker entries to watch.  The
  # classes that subclass from Entry are: Equity, Currency, Future, and
  # Option.
  class Entry
    
    # @symbol represents the ticker symbol for an entry (e.g., AAPL, MSFT,
    # etc.)  @description is an optional string that can give a more
    # user-friendly description of a symbol.  If a description is not
    # provided, the symbol itself is displayed to the user.  If the user
    # provides information on having purchased an entry (for example AAPL
    # stock), the user may specify how many via @purchase_count (in this case
    # how many shares), and for how much via @purchase_price (in this case
    # how much paid per share).  A user can specify a negative
    # @purchase_count to represent a SHORT position.  @bold specifies if
    # this entry should stand apart from other entries when displayed to the
    # user.
    attr_accessor :symbol, :description, :purchase_count, :purchase_price
    attr_accessor :bold, :curr_value, :last_changed
    
    alias bold? bold
    
    def initialize (symbol, description=nil, purchase_count=nil, purchase_price=nil, bold=false)
      @symbol = symbol
      @description = description
      @purchase_count = purchase_count
      @purchase_price = purchase_price
      @bold = bold
      @last_changed = nil
    end
  end
  
  ##############################
  # Represents stocks/equities (e.g. AAPL, MSFT)
  class Equity < Entry
    # Equities can be retrieved via either Google Finance or Yahoo Finance.
    # @source should be set to one of either :google (the default) or :yahoo.
    # @start_value represents the value of the equity at market open.
    
    attr_accessor :start_value, :source

    def initialize (symbol, description=nil, purchase_count=nil, purchase_price=nil, bold=false)
      super(symbol, description, purchase_count, purchase_price, bold)
      @start_value=nil
      @source=:google
    end

    def Equity.update (entries, source=:google)
      if source == :google
        Equity.update_google(entries)
      elsif source == :yahoo
        Equity.update_yahoo(entries)
      else
        raise ArgumentError, "Unexpected symbol: #{source.to_s}"
      end
    end

    def Equity.update_google (entries)
      symbols = entries.map { |e| e.symbol }
      uri = "http://www.google.com/finance/info?client=ig&q=%s" % symbols.join(",")
      response = Net::HTTP.get(URI.parse(URI.escape uri)) rescue return
      return if response =~ /illegal/ # Google didn't like our request.
      results = response.split("{")[1..-1]
      entries.zip(results) do |entry, result|
        # Fish out the info we want.  Could use a JSON library, but that's
        # one more gem that would be required of the user to install.  Opted
        # instead for just two lines of super ugly code.
        price  = result.grep(/"l"/)[0].chomp.split(":")[-1].split('"')[-1].tr(',', '')
        change = result.grep(/"c"/)[0].chomp.split(":")[-1].split('"')[-1].tr(',', '')
        if price.to_f != entry.curr_value and not entry.curr_value.nil?
          # The price has changed
          entry.last_changed = Time.now() 
        end
        entry.curr_value  = price.to_f
        entry.start_value = entry.curr_value - change.to_f
      end
    end

    def Equity.update_yahoo (entries)
      symbols = entries.map { |e| e.symbol }
      uri = "http://download.finance.yahoo.com/d/quotes.csv?s=%s&f=l1c1va2xj1b4j4dyekjm3m4rr5p5p6s7" % symbols.join(",")
      response = Net::HTTP.get(URI.parse(URI.escape uri)) rescue return
      #return if response =~ /=/ # This is a sign yahoo is giving us bad info
      results = response.split("\n")
      entries.zip(results) do |entry, result|
        # Yahoo uses A CSV format.
        fields = result.split(",")
        price  = fields[0]
        change = fields[1]
        if price.to_f != entry.curr_value and not entry.curr_value.nil?
          # The price has changed
          entry.last_changed = Time.now() 
        end
        entry.curr_value  = price.to_f
        entry.start_value = entry.curr_value - change.to_f
      end
    end
  end

  ##############################
  # Represents futures contracts (e.g., oil, gold, corn, wheat)
  class Future < Entry
    # Futures contracts expire on a given month and year.  Let's track that
    # information to display to the user.  Might as well show the @market
    # that the contract is traded on, too.  For instance oil can be traded via
    # NYMEX or ICE (InterContinental Exchange).  Also, because we won't know
    # ahead of time what the nearest expiration for a contract will be, we'll
    # have to figure this out for each contract with web calls.  Once we know
    # the expiration, we'll calculate the real symbol for the contract and
    # store it in @real_symbol.
    attr_accessor :start_value, :exp_month, :exp_year, :market
    attr_accessor :real_symbol

    # Commodities have strange codes for months
    COMMODITY_MONTHS = %w[F G H J K M N Q U V X Z]

    def initialize (symbol, description=nil, purchase_count=nil, purchase_price=nil, bold=false)
      super(symbol, description, purchase_count, purchase_price, bold)
      @start_value=nil
      @exp_month=nil
      @exp_year=nil
      @market=nil
      @real_symbol=nil
    end

    def Future.update (entries)
      # Futures are special.  The first run requires us to find the spot
      # contract for the commodity in question.  The spot contract is simply
      # the closest expiring contract that is still open for trades.
      # Determining the spot contract is not always clear, and so we must
      # brute force to find the answer.  When we find the spot contract, we
      # set the entry's real_symbol attribute to the actual spot contract's
      # symbol.  Got it?
      if entries.any? {|e| e.real_symbol.nil?}
        #puts "Please wait... determining spot contracts"
        threads = []
        for entry in entries
          if not entry.real_symbol
            threads << Thread.new { entry.determine_spot_contract }
          end
        end
        threads.each {|t| t.join}
      end

      # All spot contracts have been found.  Now let's update our entries
      # with the latest price information.  This is what we came here for!
      symbols = entries.map { |e| e.real_symbol }
      uri = "http://download.finance.yahoo.com/d/quotes.csv?s=%s&f=l1c1va2xj1b4j4dyekjm3m4rr5p5p6s7" % symbols.join(",")
      response = Net::HTTP.get(URI.parse(URI.escape uri)) rescue return
      results = response.split("\n")
      entries.zip(results) do |entry, result|
        # Yahoo uses A CSV format.
        fields = result.split(",")
        return if fields[4] == '""' # This is a sign yahoo is giving us bad info
        price  = fields[0]
        change = fields[1]
        if price.to_f != entry.curr_value and not entry.curr_value.nil?
          # The price has changed
          entry.last_changed = Time.now() 
        end
        entry.curr_value  = price.to_f
        entry.start_value = entry.curr_value - change.to_f
      end
    end # def

    def determine_spot_contract
      # This is as nasty as it gets.  Keep trying contracts, month after
      # month, until we find a valid one.  Stop after 9 failed attempts.
      attempt_count = 9 # Maximum number of attempts to try

      symbol, exchange = @symbol.split(".")
      @market = exchange
      curr_month = curr_year = nil
      
      while attempt_count > 0
        if curr_month.nil?
          # By default start looking at next month.  Also, let's use a zero
          # based index into months.  Jan == 0, Dec == 11
          curr_month = Time.now().month % 12
          curr_year  = Time.now().year
        else
          curr_month = (curr_month + 1) % 12
        end
        curr_year += 1 if curr_month == 0  # We've rolled into next year
        month_symbol = Future::COMMODITY_MONTHS[curr_month]
        year_symbol = curr_year % 100 # Only want last two digits of year.
        real_symbol_attempt = "#{symbol}#{month_symbol}#{year_symbol}.#{exchange}"
        uri = "http://download.finance.yahoo.com/d/quotes.csv?s=%s&f=l1c1va2xj1b4j4dyekjm3m4rr5p5p6s7" % real_symbol_attempt
        response = Net::HTTP.get(URI.parse(URI.escape uri)) rescue return

        # This contract is only valid if the response doesn't start with
        # 0.00.  A commodity is never worth nothing!
        unless response =~ /^0.00/
          @real_symbol = real_symbol_attempt
          @exp_month = curr_month+1 # Convert from 0-based back to 1-based
          @exp_year = curr_year
          break # Get out of this loop!
        end
        attempt_count -= 1
      end # while

      if attempt_count == 0 and @real_symbol.nil?
        # Can't determine month for this contract.  Set the real_symbol to
        # symbol and hope for the best.
        @real_symbol = @symbol
      end
    end # def

  end

  ##############################
  # Represents currency pairs (e.g. USD/EUR)
  class Currency < Entry
    # In the context of currency pairs, each increment in @purchase_count
    # represents single units of the quote currency exchanged for the base
    # currency.  (The base currency is the first of the pair, the quote
    # currency is the second.)  @purchase_price represents the pair ratio
    # when the purchase was made.  For instance, a @purchase_count of 1000
    # and @purchase_price of 1.412 for the currency pair 'EUR/USD' means that
    # $1000 USD was swapped for 708.21 euros.  A *negative* @purchase_count
    # of -1000 would mean that 1000 euros were swapped for $1,412 USD.

    def Currency.update (entries)
      symbols = entries.map { |e| e.symbol }
      uri = "http://download.finance.yahoo.com/d/quotes.csv?s=%s&f=sl1d1t1ba&e=.csv" % symbols.map{|x| x+"=X"}.join(",")
      response = Net::HTTP.get(URI.parse(URI.escape uri)) rescue return
      return if response =~ /"N\/A"/ # Yahoo sometimes returns bogus info.
      results = response.split("\n")
      entries.zip(results) do |entry, result|
        # Yahoo uses A CSV format.
        fields = result.split(",")
        price = fields[1]
        if price.to_f != entry.curr_value and not entry.curr_value.nil?
          # The price has changed
          entry.last_changed = Time.now() 
        end
        entry.curr_value = price.to_f
        # Currencies aren't regulated.  So no need to calculate the
        # @start_value, because there is no market open.  Currencies trade
        # 24/7
      end
    end
  end

  ##############################
  # Represents option contracts which are derivatives of either equities,
  # indexes or futures.
  class Option < Entry
    # Because option contracts are not traded as much as their underlying,
    # the bid/ask spread can be pretty high and there might be quite a bit of
    # time since a trade has occurred for a given contract.  Therefore it is
    # sometimes more meaningful to represent the value of an option by
    # showing both the current bid and ask prices rather than the last trade
    # price.
    attr_accessor :bid, :ask

    def initialize (symbol, description=nil, purchase_count=nil, purchase_price=nil, bold=false)
      super(symbol, description, purchase_count, purchase_price, bold)
      @bid = @ask = nil
    end

    def Option.update (entries)
      threads = []
      for entry in entries
        # Can only grab one option contract at a time, so request each one in
        # a separate thread.
        threads << Thread.new do
          uri = "http://finance.yahoo.com/q?s=%s" % entry.symbol
          response = Net::HTTP.get(URI.parse(URI.escape uri)) rescue break
          # Rake through the HTML and find the bits we want.
          # This can be a bit messy.
          begin
            bid_ask_line = response.grep(/Bid/)[0]
            bid = bid_ask_line.split("yfs_b00_")[1].split(">")[1].split("<")[0]
            ask = bid_ask_line.split("yfs_a00_")[1].split(">")[1].split("<")[0]
          rescue
            # These results aren't available from about 9am to 9:30am.
            # Yahoo's results are often 20-30 minutes behind.
            break
          end
          if (bid.to_f != entry.bid or ask.to_f != entry.ask) and not entry.bid.nil?
            # The price has changed
            entry.last_changed = Time.now() 
          end
          entry.bid = bid.to_f
          entry.ask = ask.to_f
          # The value is the mean average of the bid/ask spread
          entry.curr_value = (entry.bid + entry.ask) / 2
        end
      end
      threads.each {|t| t.join}
    end
  end

  ##############################
  # This class is simply used to represent a separator when displaying
  # entries to the user.
  class Separator
  end

  ##############################
  # Read options from the command line
  def RTicker.parse_argv! (options={})

    # Use OptionParser to parse command line arguments
    optparse = OptionParser.new do |opts|
      opts.banner = "Usage: rticker [-oenh] [-f FILE] ... [SYMBOL[,DESC[,COUNT@PRICE]]] ..."
      
      options[:once] = false
      opts.on("-o", "--once", "Only display ticker results once then quit") do
        options[:once] = true
      end
      
      options[:no_color] = false
      opts.on("-n", "--no-color", "Do not use colors when displaying results") do
        options[:no_color] = true
      end
      
      options[:file] = []
      opts.on("-f", "--file FILE", "Specify a file that lists ticker entries, one per line") do |file|
        options[:file] << file
      end

      options[:sleep] = 2
      opts.on("-d", "--delay SECS", "How long to delay in SECS between each update") do |secs|
        options[:sleep] = secs.to_f
      end
      
      opts.on("-h", "--help", "Display this screen") do 
        puts opts
        exit
      end

      # Parse options and pop recognized options out of ARGV.
      # If a parse error occurs, print help and exit
      begin
        opts.parse! 
      rescue OptionParser::ParseError => e
        STDERR.puts e.message, "\n", opts 
        exit(-1)
      end
    end

    # Return options
    options
  end

  ##############################
  # Read raw text entries, line by line, from file.  Return result as an
  # array of text entries.  File "-" represents STDIN.
  def RTicker.read_entry_file (file)
    # If we're not dealing with a readable source then get out of here
    return [] unless File.readable? file or file == "-"

    entries = []
    source = if file == "-" then $stdin else File.open(file) end
    source.each do |line|
      line.chomp!
      case line
      when  /^;/, /^\s*$/
        # If this line starts with a semicolon (comment) or only contains
        # whitespace, ignore it.
        next
      when /^@.+/
        # If this line starts with an @ sign, then this is an 'include'
        # directive.  Ie, this entry is simply including another entry file.
        # Eg: @otherfile.txt
        # This will include another file called otherfile.txt
        entries += read_entry_file(line[1..-1])
      else
        entries << line
      end
    end

    entries
  end

  ##############################
  # Parse a raw text entry into an instance of Equity, Future, Currency,
  # Option, or Separator.
  def RTicker.parse_entry (entry)

    # An entry starting with a dash represents a Separator
    return Separator.new if entry[0,1] == "-"

    # An entry beginning with an asterisk represents a bold entry.
    bold = false
    if entry[0,1] == "*"
      bold = true
      entry = entry[1..-1] # Shift off asterisk
    end
    
    ## Here is a breakdown of the format: 
    ## [sign]symbol[,desc[,purchase_count@purchase_price]]
    ## Where sign can be a "#" (Future), "!" (Option), "^" (Yahoo Equity), 
    ## or "$" (Currency).  Anything else represents a Google Equity.
    pattern = /^([#!^$])?([^,]+)(?:,([^,]*)(?:,(-?[0-9]+)@([0-9]+\.?[0-9]*))?)?/
    match = pattern.match entry

    sign = match[1]
    symbol = match[2]
    # Because description is optional, let's make it clear with a nil that no
    # description was provided.
    description = match[3] == "" ? nil : match[3]
    purchase_count = match[4]
    purchase_price = match[5]

    args = [symbol, description, purchase_count.to_f, purchase_price.to_f, bold]
    case sign
    when "#"
      # An entry starting with a hash is a Future.  A useful mnemonic is to
      # think of the "pound" sign and think of lbs of a commodity.
      return Future.new(*args)
    when "!"
      # An entry starting with an exclamation mark is an option contract.
      return Option.new(*args)
    when "^"
      # An entry starting with a caret represents an equity to be fetched
      # from Yahoo Finance.
      e = Equity.new(*args)
      e.source = :yahoo
      return e
    when "$"
      # An entry starting with a dollar sign represents a currency pair.
      return Currency.new(*args)
    else
      # Everthing else is an equity to be fetched from Google Finance (the
      # default).
      return Equity.new(*args)
    end
  end

  ##############################
  # tput is a command line utility used for sending special terminal codes.
  # This method is memoized to cut down on execution time.
  $__tput_cache = {}
  def RTicker.tput (args)
    if $__tput_cache.has_key? args
      $__tput_cache[args]
    else
      $__tput_cache[args] = %x[tput #{args}]
    end
  end

  ##############################
  # Update the screen with the latest information.
  def RTicker.update_screen (entries, no_color=false, once=false)
    # An interesting side-effect of using unless here is that if no_color is
    # true, then all of these variables are still created, but set to nil.
    # So setting no_color effectively turns all of the following variables
    # into empty strings, turning off terminal manipulation.
    hide_cursor = tput "civis" unless no_color
    show_cursor = tput "cnorm" unless no_color
    bold = tput "bold" unless no_color
    unbold = tput "sgr0" unless no_color
    default = tput "sgr0" unless no_color
    red = tput "setaf 1" unless no_color
    green = tput "setaf 2" unless no_color
    blue = tput "setaf 4" unless no_color

    if not once
      print %x[clear]
      print "#{hide_cursor}"
    end
    print "#{default}"
    
    # Calculate the longest symbol name or description
    max_length = 0
    for entry in entries.select {|e| not e.is_a? Separator}
      output = entry.description || entry.symbol
      max_length = [output.size, max_length].max
    end
    max_length += 2 # Give a little extra breathing room

    for entry in entries
      if entry.is_a? Separator
        print "___________________________________________\n"
        next # Skip to the next entry
      end

      # Prefer a description over a raw symbol name.  Use max_length to left
      # align the output with extra padding on the right.  This lines
      # everything up nice and neat.
      output = "%-#{max_length}s" % (entry.description || entry.symbol)
      output = "#{bold}#{output}#{unbold}" if entry.bold?

      # If we're still waiting for valid responses from yahoo or google, then
      # just let the user know that they need to wait.
      curr_value = entry.curr_value || "please wait..."

      if entry.is_a? Option
        curr_value = "#{entry.bid}/#{entry.ask}" if entry.bid
      end

      # Does this entry have a start_value?  If so, let's calculate the
      # change in percent.
      change_string = nil
      if entry.respond_to? :start_value and not entry.start_value.nil?
        change = entry.curr_value - entry.start_value
        change_percent = (change / entry.start_value) * 100
        color = (change >= 0 ? "#{green}" : "#{red}")
        change_string = " (#{color}%+.2f %%%0.2f#{default})" % [change, change_percent]
      end

      # If this entry has purchase info, let's calculate profit/loss
      profit_string = nil
      if entry.purchase_count != 0 and not entry.curr_value.nil?
        count = entry.purchase_count
        price = entry.purchase_price
        # Options are purchased in multiples of 100 of the contract price
        count *= 100 if entry.is_a? Option 
        # There is also a price multiplier for futures, but they are
        # completely different for each contract.  So the user will simply
        # need to enter the correct multiplier when configuring the
        # purchase_count in the ticker entry.  For instance, a contract for
        # CL, crude light sweet oil, has a multiplier of 1000.  Ie, one
        # contract represents 1000 barrels of oil.  So if a contract is
        # bought, the user should enter a purchase_count of 1000.  If the
        # contract is sold (a short position), the purchase_count should be
        # -1000.
        profit_loss = count * entry.curr_value - count * price
        profit_loss_percent = profit_loss / (count*price) * 100
        color = (profit_loss >= 0 ? "#{green}" : "#{red}")
        profit_string = " = #{color}$%.2f %%%0.2f#{default}" % [profit_loss, profit_loss_percent]
      end

      case entry
      when Equity
        print "#{output} #{curr_value}#{change_string}#{profit_string}"
      when Future
        print "#{output} #{curr_value}#{change_string}#{profit_string}"
      when Option
        print "#{output} #{curr_value}#{profit_string}"
      when Currency
        print "#{output} #{curr_value}#{profit_string}"
      end

      # Let the user know with a blue asterisk if this entry has changed
      # within the past 5 minutes.
      if entry.last_changed and (Time.now() - entry.last_changed) <= 5*60
        print " #{blue}*#{default}"
      end

      print "\n"
    end # for
    
  end # def

  ##############################
  # main
  def RTicker.main ()
    # Parse recognizable options from command line.  Strips away recognizable
    # options from ARGV.
    options = parse_argv!
    
    # text_entries is an array of ticker entries in raw text format.
    # Any left over arguments in ARGV should be ticker entries
    text_entries = ARGV
    
    options[:file].each do |file|
      # For each file passed via the CLI, read its entries into text_entries.
      text_entries += read_entry_file(file)
    end
    
    if text_entries.empty?
      # If no entries were passed via CLI, then try to read from $HOME/.rticker
      text_entries += read_entry_file(DEFAULT_ENTRY_FILE) 
    end

    if text_entries.empty?
      # Still no entries?  Then there's nothing to do.
      puts "No ticker entries provided.  Exiting."
      exit
    end
    
    # Parse text_entries into instances of Equity, Future, Currency, Option,
    # and Separator
    entries = text_entries.map {|entry| parse_entry(entry)}

    currency_entries = entries.select {|e| e.instance_of? Currency }
    option_entries = entries.select {|e| e.instance_of? Option }
    future_entries = entries.select {|e| e.instance_of? Future }
    google_equity_entries = entries.select {|e| e.instance_of? Equity and e.source == :google  }
    yahoo_equity_entries = entries.select {|e| e.instance_of? Equity and e.source == :yahoo  }
    
    # Don't raise an exception when user hits Ctrl-C.  Just exit silently
    Signal.trap("INT") do
      # Show the cursor again and shutdown cleanly.
      print tput "cnorm"
      exit
    end

    # Update entries via web calls until user quits via Ctrl-C
    while true
      threads = []

      # Update each type of entry in its own thread.
      threads << Thread.new { Currency.update(currency_entries) }
      threads << Thread.new { Option.update(option_entries) }
      threads << Thread.new { Future.update(future_entries) }
      threads << Thread.new { Equity.update(google_equity_entries, :google) }
      threads << Thread.new { Equity.update(yahoo_equity_entries, :yahoo) }

      # Wait for them all to finish executing
      threads.each {|t| t.join}

      # Show updated info to the user
      update_screen entries, options[:no_color], options[:once]

      # If the user only wanted us to grab this info and display it once,
      # then we've done our job and its time to quit.
      exit if options[:once]

      sleep options[:sleep]
    end
  end # main

end # module

# If this script is called from the command line, then call the main
# method to run the application.  Otherwise, this file is being loaded as
# a library, so do not call main.
RTicker::main if __FILE__ == $0
